## Как реализовать оператор if в командной строке Bash
Как такие операторы if также могут использоваться внутри скриптов Bash
Примеры, демонстрирующие работу if, elif, else, then и fi в Bash

**Содержание**
* Пример 1: простой оператор if в командной строке
* Пример 2: Использование оператора if в скрипте оболочки Bash
* Пример 3: Что такое elif?

### Заключение
Пример 1: простой оператор if в командной строке
$ if [ 1 -eq 1 ]; then echo "Matched!"; fi
Matched!
В этом примере мы сравниваем один к одному.

Обратите внимание, что -eq означает равно.

Чтобы сделать обратное, можно использовать -ne, что означает не равно, как показано в следующем примере:

$ if [ 0 -ne 1 ]; then echo "Matched!"; fi
Matched!
В этом случае мы проверили неравенство, и, поскольку 0 не равно 1, оператор if верен, и команды после then будут выполнены.
Давайте немного изменим это:
$ if [ 1 -ne 1 ]; then echo "Matched!"; else echo "Not Matched!"; fi
Not Matched!
Здесь мы ввели оператор else; какие команды выполнять, если условие в инструкции if оказалось ложным (или неверным).

Когда мы пытаемся запросить, не равно ли 1 (-ne) на этот раз 1, и поскольку 1 действительно равно 1, условие, сформулированное в этом операторе if, ложное, и мы сталкиваемся с нашим оператором else с выведенным совпадающим текстом.

Пример 2: Использование оператора if в скрипте оболочки Bash
Стоит отметить, что вы можете легко скопировать и вставить любой оператор if, показанный здесь или где-либо еще, и использовать его внутри скрипта оболочки Bash.

Например:
```
$ echo '#!/bin/bash' > myscript.sh
$ echo 'if [ 1 -eq 1 ]; then echo "Matched!"; fi' >> myscript.sh 
$ chmod +x myscript.sh 
$ ./myscript.sh 
Matched!
$ 
```

Здесь мы просто создали небольшой скрипт оболочки myscript.sh, используя echo и перенаправитель > для перенаправления вывода из нашего echo в файл.

Когда вы используете >, будет создан новый файл, и любой файл с таким же именем будет перезаписан, поэтому используйте его с осторожностью.

Затем мы снова добавляем наш оператор if, используя эхо и двойной перенаправитель >>, который, в отличие от >, не создает новый файл, а просто добавляет текст в указанный файл.

Затем мы chmod + x на скрипт, чтобы сделать его исполняемым, и выполняем скрипт с префиксом ./, который требуется в bash (подойдет любой правильный указатель пути).

Первая строка скрипта просто убеждается, что мы будем использовать интерпретатор bash для нашего скрипта.

Рекомендуется всегда устанавливать его в bash и других скриптах (для других скриптов вы можете установить любой интерпретатор, который будет выполнять ваш сценарий, например #!/Usr/bin/python3 для Python 3 ( .py3 например) и т. д.).

Когда мы выполняем скрипт, мы видим, что результат генерируется как ожидалось (1 соответствует 1).

Matched!
Пример 3: Что такое elif?
Операто elif обеспечивает дополнительную гибкость сокращений, минимизируя необходимость вложенных операторов.

Рассмотрим следующий скрипт test.sh:

#!/bin/bash
if [ 0 -eq 1 ]; then 
  echo '0=1'
else
  if [ 0 -eq 2 ]; then
    echo '0=2'
  else
    echo '0!=2'
  fi
fi
И вывод из него:

$ ./test.sh
0!=2
Здесь мы прошли через первый оператор if, и поскольку 0 не соответствует 1, активируется else.
Это происходит во второй раз, когда 0 также оказывается не равным 2, и, следовательно, условие -eq (equal to) не выполняется, а второе else активируется, давая на выходе 0! = 2.
Давайте сравним это с оператором на основе elif в следующем test2.sh.
#!/bin/bash
if [ 0 -eq 1 ]; then
  echo '0=1'
elif [ 0 -eq 2 ]; then
  echo '0=2'
else
  echo '0!=2'
fi
Вывод:

$ ./test2.sh
0!=2
Скрипт делал то же самое, но гораздо более гибким и коротким способом, требуя только одного уровня глубины оператора if и с более чистым общим кодом.

Также обратите внимание, что можно иметь один оператор if, за которым следует множество операторов elseif, что позволяет разработчику тестировать множество условий и представляет собой аккуратную одноуровневую структуру.
